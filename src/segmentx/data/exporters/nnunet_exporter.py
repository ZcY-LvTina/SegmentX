"""Export helpers to convert Volume3D into nnU-Net friendly layouts."""

from __future__ import annotations

import json
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, List, Optional

import numpy as np

from ..volume_loader import Volume3D
from ...utils.paths import ensure_dir

try:
    import nibabel as nib  # type: ignore
except Exception:  # pragma: no cover - optional dependency
    nib = None


@dataclass
class ExportResult:
    case_id: str
    image_path: Path
    label_path: Optional[Path] = None


class NNUNetExporter:
    """Convert Volume3D to nnU-Net dataset layout."""

    def __init__(self, output_root: Path) -> None:
        self.output_root = ensure_dir(Path(output_root))

    def export_inference_volume(self, volume: Volume3D, case_id: str) -> ExportResult:
        if nib is None:
            raise RuntimeError("nibabel is required to export NIfTI. Install with `pip install nibabel`.")
        images_dir = ensure_dir(self.output_root / "imagesTs")
        image_path = images_dir / f"{case_id}_0000.nii.gz"
        self._write_nifti(volume.data, volume.metadata.spacing, image_path)
        return ExportResult(case_id=case_id, image_path=image_path)

    def export_training_pair(
        self,
        volume: Volume3D,
        label_volume: Volume3D | np.ndarray,
        case_id: str,
        labels: Optional[Dict[int, str]] = None,
    ) -> ExportResult:
        if nib is None:
            raise RuntimeError("nibabel is required to export NIfTI. Install with `pip install nibabel`.")
        images_dir = ensure_dir(self.output_root / "imagesTr")
        labels_dir = ensure_dir(self.output_root / "labelsTr")
        image_path = images_dir / f"{case_id}_0000.nii.gz"
        label_path = labels_dir / f"{case_id}.nii.gz"

        self._write_nifti(volume.data, volume.metadata.spacing, image_path)
        label_data = label_volume.data if isinstance(label_volume, Volume3D) else label_volume
        self._write_nifti(label_data, volume.metadata.spacing, label_path)

        dataset_json = self.output_root / "dataset.json"
        if not dataset_json.exists():
            self._write_dataset_json(dataset_json, labels=labels or {})
        return ExportResult(case_id=case_id, image_path=image_path, label_path=label_path)

    def _write_dataset_json(self, path: Path, labels: Dict[int, str]) -> None:
        payload = {
            "name": "SegmentXDataset",
            "description": "Generated by SegmentX NNUNetExporter",
            "tensorImageSize": "4D",
            "reference": "",
            "licence": "CC-BY",
            "release": "1.0",
            "modality": {"0": "CT"},
            "labels": {str(idx): name for idx, name in labels.items()},
            "numTraining": 0,
            "numTest": 0,
            "training": [],
            "test": [],
        }
        path.write_text(json.dumps(payload, indent=2), encoding="utf-8")

    def _write_nifti(self, data: np.ndarray, spacing, path: Path) -> None:
        affine = np.eye(4)
        if len(spacing) == 3:
            affine[0, 0] = spacing[0]
            affine[1, 1] = spacing[1]
            affine[2, 2] = spacing[2]
        img = nib.Nifti1Image(data.astype(np.float32), affine)
        nib.save(img, path)
